# TCP-HTTP-IP
关于对TCP、HTTP、IP协议的理解

---

#### 一、基本概念

+  **OSI网络模型分层：**由下往上分为7层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

   如图：

![](https://ws4.sinaimg.cn/large/006tNc79gy1fp438quercj30jg0rktdo.jpg)



+  **HTTP协议属于应用层**（HTTP协议负责包装数据）。

+  **TCP协议属于传输层**（TCP协议负责加工切割包,并分配给IP层进行运输,时刻监控IP层的行踪）。

+  **IP协议属于网络层**（IP协议负责包运输）。

+  而**Socket（套接字）属于抽象层**，是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。说白了Socket本身并不是协议，而是对TCP/IP协议的封装而形成的API。通过Socket，我们才能使用TCP/IP协议。

   实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象。从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。

   网络有一段关于Socket和TCP/IP协议关系的说法比较容易理解：
   　　“TCP/IP只是一个协议栈，就像操作系统的运行机制，必须要具体实现，同时还要提供对外的操作接口。
   　　这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，
   　　TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”

   ​	![](https://ws3.sinaimg.cn/large/006tNc79gy1fp49741h33j30f20d8ta3.jpg)

+  **总结**：

   +  **HTTP、TCP、IP**三者从本质上来说，因为不属于同一层，所以没有可比性。
   +  **HTTP**将数据包装后，使用**TCP**的传输能力，将数据信息传输出去。
   +  我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是如果没有应用层，便无法识别数据内容。如果想要使传输的数据有意义，则必须使用到应用层协议。而应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。
   +  WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。
   +  实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。
   +  **应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务**

+  ##### 给你们讲个故事哈哈哈：

   中秋节到了，上海的老王想给北京的好友老张快递一些节日礼物，有鲜肉月饼、大闸蟹等，老王选择了机器人快递公司，听说送快递的全是机器人。

   老王把礼物打好包并转交给快递公司，并叮嘱快递公司，要**鲜肉月饼先到，大闸蟹后到**，快递公司说：okay，放心好了。

   快递公司将**鲜肉月饼贴上标签1，大闸蟹标签2**，放在仓库里，**先联系到北京的老张再发货**。

   于是快递公司派出机器人小哥，给小哥输入老张、老王的地址信息：

   收件人地址
   北京海淀区知春路xx号

   寄件人地址
   上海浦东新区世纪大道200号

   机器人用导航软件智能选取路线，过程不表。

   联系老张的过程（**三次握手**）：

   机器人A到达北京快递公司，快递公司看到老张的地址信息，去他家敲敲门，**老张你在家吗？等会有快递要送过来，务必在家哦（服务器TCP端口号活）**，老张说好的好的。

   北京的快递公司派出机器人B回复上海方面，老张在家的，快递可以运过来了。

   上海的快递公司派出机器人A回复北京，快递马上就发出，请稍候。

   有同学说，需要那么麻烦嘛？打个电话不就行了吗？没错，但**这只是一个虚拟故事，在这个故事里没有电话，只有跑腿的机器人。**

   以上联系老张的过程就是**三次握手**，**机器人A、B都是空载，什么货物也没有运，只是起到消息传递的作用**，接下来开始运送货物了。

   上海的快递公司让机器人C运鲜肉月饼，机器人D运大闸蟹，于是C、D先后上路了。

   C的导航软件让他走沪陕高速，结果堵成狗了，高速成了停车场。

   D的导航软件让他走京沪高速，虽然有点堵，但还是后发先至，结果比C先到北京的快递公司。

   北京的快递公司将**D运的礼物放在仓库里（缓存）**，耐心地等待C的到来，第二天C终于还是到了。

   快递公司将**货物按标签1、2按照顺序转交给了老张。**

   快递公司稍后还要派出机器人通知上海方面，货物（标签1、2）安全到达，请勿挂念。

   老张心情大好，来而不往非礼也，于是将北京烤鸭、北京糕点打包好，让快递公司转交给老王，只有一个叮嘱，**烤鸭先到，糕点后到（按序）**。

   过程与上类似，机器人E运烤鸭，机器人F运糕点。

   E走京沪高速，结果在某某大桥出车祸了，被撞到江里了，game over。

   F走沪陕高速，堵了三天三夜没动弹。

   北京的快递公司左等等、右等等，上海方面一点消息也没有，**知道最坏的情况发生了，但快递公司有自己的预案**，三天没有对方的消息，就默认机器人挂了，需要重新安排机器人重新运货物。

   于是机器人G运烤鸭、H运糕点又重新上路了。

   这次非常顺利，G、H走的都是京沪高速，按序到达了上海快递公司，不一会，F也到了，快递公司很恼火，对F很不客气滴说：你现在是多余的人（**F与H是重复的货物，需要丢一个**），快滚！

   上海的快递公司于是将烤鸭、糕点按序转交给老王。

   稍后再派出机器人通知北京方面，烤鸭、糕点已经安全到达，请不要再发重复的货物过来！

   在这个虚拟故事里，

   **老王是http客户端，老张是http服务器端**，负责将什么样的礼物（数据）送给对方，同时负责解释这些礼物的真正含义。

   **快递公司是TCP**，负责将客户的数据**按序（客户的数据按序才有意义）**送到客户指定的目的地，如果有丢失，TCP负责重传。

   **机器人是IP**，根据快递公司输入的客户目的地，根据导航软件将货物送到目的地，如果有丢件，机器人无能为力。**IP**只会根据目的地找人，但是在找人的过程中随时可能夭折，所以需要TCP时刻监控IP的行踪。如何监控？其实就是依靠自身的定时器与对方的消息配合。

   **HTTP**将数据包装后，使用**TCP**的传输能力，将数据信息传输出去。

   ​

#### 二、利用Socket建立网络连接的步骤

​	建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。
　　套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
　　1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
　　2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。
　　为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
　　3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。



#### 三、TCP连接的三次握手和四次挥手

##### 1.什么是TCP连接的三次握手（连接）

![](https://ws3.sinaimg.cn/large/006tNc79gy1fp49fpjtsfj30jg0ddmz3.jpg)

​	第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;

　　第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;

　　第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，并分配资源。此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

​	我们也可以理解成：

​	1.A向B发起建立连接请求：A——>B；

​	2.B收到A的发送信号，并且向A发送确认信息：B——>A

​	3.A收到B的确认信号，并向B发送确认信号：A——>B。

​	通过第一次握手，B知道A能够发送数据。通过第二次握手，A知道B能发送数据。结合第一次握手和第二次握手，A知道B能接收数据。结合第三次握手，B知道A能够接收数据。

​	使用三次握手的原因：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接

​	三次连接是保证可靠的最小握手次数，再多次握手也不能提高通信成功的概率，反而浪费资源。

​	握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

　　理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
　　断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次挥手”

##### 2.什么是TCP的四次挥手（断开）

![](https://ws1.sinaimg.cn/large/006tNc79gy1fp49fyniq1j30jg0ej76r.jpg)

​	1.A向B发起请求，表示A没有数据要发送了：A——>B；

​	2.B向A发送信号，确认A的断开请求：B——>A；

​	3.B向A发送信号，请求断开连接，表示B没有数据要发送了：B——>A；

​	4.A向B发送确认信号，同意断开：A——>B。

​	B收到确认信号，断开连接，而A在一段时间内没收到B的信号，表明B已经断开了，于是A也断开了连接。至此，完成挥手过程。

​	**注意中断连接端可以是Client端，也可以是Server端**

​	假设Client端发起中断请求，也就是发送FIN报文，意思是说：我没有数据要发送了。Server端接到FIN报文后，如果还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以Server端先发送ACK，告诉Client端：“你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文告诉Client端：”好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

​	**注意在TIME_WAIT状态中，如果Client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。**

​	1.为什么连接的时候是三次握手，关闭的时候却是四次握手？

​	因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。也就是说：挥手次数比握手多一次，是因为握手过程，通信只需要处理**连接**。而挥手过程，通信需要处理**数据+连接**

​	2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

​	为了保证发送的最后一个ACK报文段能够到达B。

​	防止“已失效的连接请求报文段”出现在本连接中。在发送完最后一个ACK报文段后，再经过实践2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种就得连接请求报文段。

​	3.为什么2、3次挥手不能合在一次挥手中？

​	那是因为此时A虽然不再发送数据了，但是还可以接收数据，B可能还有数据要发送给A，所以两次挥手不能合并为一次。



​	**整个过程Client端所经历的状态如下：**

​		![](https://ws1.sinaimg.cn/large/006tNc79gy1fp49jesa7oj30dw0czmya.jpg)	

​	**而Server端所经历的过程如下：**

​		![](https://ws3.sinaimg.cn/large/006tNc79gy1fp49jhwnfkj30ep0d6jse.jpg)





#### 四、HTTP链接的特点

　　HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。
　　HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。



#### 五、TCP和UDP的区别

​	1、TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性;
　　而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。
　　2、也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。
　　知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，
　　因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，
　　即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。



#### 六、TCP的长短链接问题

​	TCP链接本身属性是不分长短的，是根据使用方式来决定的，举个例子：

​	有一把不会损坏的刀（TCP连接），你砍一个人（请求一次）就扔了（断开连接）就叫一次性砍刀（短连接），砍多个人（请求多次）扔了就叫多次性砍刀（长连接），这把刀本身的属性并不包含长短，只是根据使用方法产生了不同的叫法

​	总结：

​	HTTP连接     = 以HTTP协议为通信协议的TCP连接

​	HTTP短连接 = 以HTTP协议为通信协议的，请求一次就断开的TCP连接

​	HTTP长连接 = 以HTTP协议为通信协议的，请求多次才断开的TCP连接（这个是为了通过减少建立tcp连接的次数达到节省两端资源的目的）



#### 七、网络协议的对等通信

​	网络协议是一个栈，提供对等通信。这里解释下对等。

​	老王和老绿只与电话发生交互，他们不理解声音如何转换成电信号，也不理解电磁波如何传播。他们只知道，我对着电话说汉语，对方就能听到汉语。老王和老绿就是一个对等的协议层。两部电话也是对等的协议层，它们给上面的老王和老绿提供传输语音的服务。而电话提供的服务，底层又依赖电磁波传递无线信号。最后形成了一个个服务层，完成了打电话这个事情。再举个栗子，两个老板要约时间谈生意，他们会跟自己的秘书下达指令，让秘书搞定约会这个事。双方的秘书会互相联系，约好时间地点和司机，最后搞定这个问题。老板们不会跟对方的秘书联系（除非是小老板对马老板，那他们实际上就是不对等的），因为他们不是一个层的。

​	把上文层次的概念，放到计算机网络中，就是协议栈。协议栈的每一层，都专注于自己层的事情：HTTP专注于要传输的信息（HTTP是信息的载体，所以在协议里面会标注信息长度，信息类型等），TCP专注于传输的可靠（为了可靠传输，TCP会给自己层的包标注大小和顺序，并且有确认机制），IP负责因特网传输（IP也有自己的格式，自己查吧），再下面的层负责与局域网和硬件打交道。

​	简单来说，网络协议栈里面，每层都解决了计算机通信流程的某一环节的问题。它们使用下层提供的能力跟对方机器的相应协议层通信，给上层提供自己的服务。

​	最后，TCP的下层是IP。“我下个月结婚”这几个字，你也可以通过短信（UDP）或微信（其他传输协议）来发送。虽然传输层协议不一样（电话 vs 短信），底层还是依赖IP协议（发短信仍然需要知道对方的电话号码）。



